{
  "hash": "2a0a4b5165e145cd6135f6f0aa091012",
  "result": {
    "markdown": "---\ntitle: \"Visualising data recoding as Bipartite Graphs using igraph, tidygraph, ggraph and ggplot2\"\ndescription: \"The closest thing to a mystery-thriller that I've experienced in the ggplot2 ecosystem\"\ndate: today\ndate-modified: last-modified\ncategories:\n  - data-viz\n  - how-to\n  - ggplot2\ntags:\n  - ggplot2\n  - ggraph\n  - tidygraph\n  - igraph\n  - xmap\nfig-cap-location: bottom\ncache: true\n---\n\n\n## Bipartite Graphs? What and why?\n\nI promise this post is about making ggplots, but first some background. I've been working on a new approach to validating data pipelines which involve recoding or redistributing values between categories. The core idea of approach is to validate *Mapping Objects* instead of, or in addition, to the data itself. For more details about the appraoch see [this interview](https://ardc.edu.au/article/shaping-research-software-an-interview-with-cynthia-huang/) or the [docs for the {xmap}](https://xmap-r-pkg.netlify.app) package (pronounced \"crossmap\").\n\nMapping objects can include named vectors or lists, as well as lookup tables and crosswalks -- basically anything that encodes instructions of the form \"category A connects to category B\". For instance, when using `forcats::fct_recode()`, you might store the `new = old` mappings as a named vector specifying which `old` level \"connects\" to which `new` level as below:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-1_1e739eeec9f3ceb5db458d896a0138b3'}\n\n```{.r .cell-code}\nlibrary(forcats)\nx <- factor(c(\"apple\", \"bear\", \"banana\", \"dear\"))\nfruit_levels <- c(fruit = \"apple\", fruit = \"banana\")\nfct_recode(x, !!!fruit_levels)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] fruit bear  fruit dear \nLevels: fruit bear dear\n```\n:::\n:::\n\n\nNow given a particular mapping object, you might want to verify that it has certain properties before using. For example, when renaming columns with `dplyr::rename(...)`, where the `…` takes `new = old` pairs, you probably only want 1-to-1 relations. No 2 `old` columns should get the same `new` name, and a single `old` column being renamed into 2 `new` columns is just duplicating data.\n\nOf course this is a somewhat trivial example that you could quickly check by looking at the code, but as mappings get more complex and involve more categories, it becomes less obvious how to ensure you're actually performing the intended transformations. Add a combination of recoding, aggregating and disaggregating numeric counts (e.g. occupation level statistics, or population by administrative area) to your data wrangling pipeline and you're only one coding mistake away from accidentally (and often silently) dropping or corrupting some of your data (trust me, I've done it before).\n\nNow, where do graphs come in? Well, assertive programming is a good preventive measure against funny business in your data wrangling pipelines. However, it's not always obvious what assertions you should be checking. In the case of recoding or redistributing data, it turns out that thinking of mapping objects as directed bipartite weighted graphs is quite informative for designing assertions.\n\nAs a quick reminder, bipartite graphs are graphs where the nodes or vertices can be split into two disjoint sets, and edges or links are only allowed between the two sets, not within. The weighted part refers to the addition of a numeric attribute to each link. When the graph represents recoding or redistributing (i.e. collapsing or splitting) values, weights will be between 0 and 1. I call this graph-based representation a *Crossmap*.\n\n![A hand-drawn sketch of the Crossmap structure as a weighted directed bigraph.](images/image-1769111021.png)\n\nWith this representation we can make assertions like if we only want 1-to-1 relations, we should check that the `old` and `new` sets have the same number of unique elements:\n\n![](images/image-1921602619.png){fig-align=\"center\" width=\"483\"}\n\nNotice that this condition doesn't hold in the example above, since that is a many-to-one mapping.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-2_545ce7bdb5f8bf333ccae368de7954fa'}\n\n```{.r .cell-code}\n# old set has 2 unique elements\nunique(unname(fruit_levels))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"apple\"  \"banana\"\n```\n:::\n\n```{.r .cell-code}\n# new set has only 1 unique element\nunique(names(fruit_levels))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"fruit\"\n```\n:::\n:::\n\n\nYou can take these assertions and check them using existing assertive programming tools like [`{assertr}`](https://docs.ropensci.org/assertr/) and [`{validate}`](https://cran.r-project.org/web/packages/validate/vignettes/cookbook.html) or even just using [`{testthat}`](https://www.milesmcbain.com/posts/assertive-programming-for-pipelines/). Alternatively, the `{xmap}` (crossmap) package wraps these conditions into assertive functions that you can call before using a mapping object:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-3_b355179428256899e59e08dbe0f7c25c'}\n\n```{.r .cell-code}\nlibrary(xmap)\n\nfruit_color <- c(green = \"apple\", yellow = \"banana\") |>\n  xmap::verify_named_all_1to1()\n\nfct_recode(x, !!!fruit_color)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] green  bear   yellow dear  \nLevels: green yellow bear dear\n```\n:::\n:::\n\n\nOk, so what else can we do with these graph representations? Well, wouldn't it be nice if could easily summarise and visualise mapping objects? especially more complex ones?... and thus began my journey down the rabbit hole of graph data structures and ggplot2 extensions.\n\n## Show me the plots!\n\n<!--- insert final plot --->\n\nI'll spare you the lengthier rabbit hole detours for now (skip ahead for some failed experiments), but I've landed on using a combination of `{ggraph}`, `{tidygraph}` and `{igraph}` to power the `autoplot()` methods I want to add to the `{xmap}` package. I'm still wrapping my head around `ggproto` and how to implement new Geoms and Stats, but here's what I've learnt so far.\n\nBefore we begin, a little context:\n\n-   [`{igraph}`](https://r.igraph.org/articles/igraph.html) provides R bindings to the [core igraph](https://igraph.org/c/) network analysis library written in C. It has its own class for graphs (`igraph`) and offers a lot of graph analysis and layout algorithms that are meant much more complex graphs than a humble bipartite representation of data recoding objects.\n-   [`{tidygraph}`](https://tidygraph.data-imaginist.com) provides an tidy API for graph/network manipulation, including the `tbl_graph` class which is a thin wrapper around an `igraph` object.\n-   [`{ggraph}`](https://ggraph.data-imaginist.com/index.html) is a `ggplot2` extension which lets you turn graphs (`tbl_graph`) into ggplots using layouts, nodes and edges.\n\nAnd a note on the types of mappings I'm trying to plot. I think the crossmap format is particularly useful when you are working with combinations of one-to-one, one-to-many, many-to-one and many-to-many relations, rather than just one type of relation. For example, if you're just doing one-to-one recodings, a two-column look up table is a much more space and time efficient summary method.\n\nWith that in mind, let's see how far I got plotting the following simple crossmap that connects some nodes with `lower`case names with ones with `upper`case names with :\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-4_24f66f729e165301711a75493955ef6a'}\n\n```{.r .cell-code}\nedges_abc <- tibble::tribble(\n  ~lower, ~upper, ~share,\n  \"a\", \"AA\", 1,       # one-to-one\n  \"b\", \"BB\", 1,       # one-FROM-many / many-TO-one\n  \"c\", \"BB\", 1,\n  \"d\", \"CC\", 0.3,     # one-to-many\n  \"d\", \"DD\", 0.6,\n  \"d\", \"EE\", 0.1\n)\n```\n:::\n\n\n### A Crossmap is a Bipartite Graph, isn't it?\n\n\n::: {.cell hash='index_cache/html/setup_a4560fc790fb34f292fbf168cd232c24'}\n\n```{.r .cell-code}\nlibrary(ggraph)\nlibrary(tidygraph)\n```\n:::\n\n\nTo start with we need to convert our table of edges into a graph object. Luckily `{tidygraph}` handles this for us with ease:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-5_757295b07be9fb52625601d3eb01847b'}\n\n```{.r .cell-code}\n(tg_abc <- edges_abc |>\n  as_tbl_graph())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tbl_graph: 9 nodes and 6 edges\n#\n# A rooted forest with 3 trees\n#\n# Node Data: 9 × 1 (active)\n  name \n  <chr>\n1 a    \n2 b    \n3 c    \n4 d    \n5 AA   \n6 BB   \n# … with 3 more rows\n#\n# Edge Data: 6 × 3\n   from    to share\n  <int> <int> <dbl>\n1     1     5     1\n2     2     6     1\n3     3     6     1\n# … with 3 more rows\n```\n:::\n:::\n\n\nFrom here we just need to generate a layout and add some `geom_edge_*`s and `geom_node_*`s.\n\nWhat's a layout you ask? I had the same question. According to [`vignette(\"Layouts\", package = \"ggraph\")`](https://ggraph.data-imaginist.com/articles/Layouts.html):\n\n> In very short terms, a layout is the vertical and horizontal placement of nodes when plotting a particular graph structure. Conversely, a layout algorithm is an algorithm that takes in a graph structure (and potentially some additional parameters) and return the vertical and horizontal position of the nodes.\n\nOk, so we just need to pick a sensible layout algorithm, and lucky for me `ggraph` offers the option of using the `igraph::layout_as_bipartite()` algorithm. But wait a minute, apparently I haven't supplied a bipartite graph? And what's this `types` argument?\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-6_436d40aaf5d70189055c6f908dc407a4'}\n\n```{.r .cell-code}\ntg_abc |>\n  ggraph(layout = \"igraph\", algorithm = \"bipartite\")\n```\n\n::: {.cell-output .cell-output-error}\n```{.bg-warning}\nError in handle_vertex_type_arg(types, graph): Not a bipartite graph, supply `types' argument or add a vertex attribute named `type'\n```\n:::\n:::\n\n\n### Bipartite Graphs are a special `type` of graph, maybe too special.\n\nIt turns out that `igraph` only recognises graphs as bipartite if you add a logical `type` attribute to each of the vertices. It's not clear to me if there's an easy way to add this attribute once you've jumbled all your `to` and `from` nodes together into the `Node Data` component of a tidygraph `tbl_graph`.\n\nA somewhat cumbersome workaround is to coerce the edge list into a matrix first and then use the `as_tbl_graph.matrix()` method which handles the creation of the `type` attribute. Again lucky for me, I've been experimenting with this in the `xmap` package (because matrix representations also reveal useful assertions but I digress):\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-7_f37578c54191790c6a103f9eb62f92a0'}\n\n```{.r .cell-code}\nlibrary(xmap)\n(mtx_abc <- edges_abc |> \n  as_xmap_df(from = lower, to = upper, weights = share) |>\n  xmap_to_matrix())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4 x 5 sparse Matrix of class \"dgCMatrix\"\n     upper\nlower AA BB  CC  DD  EE\n    a  1  . .   .   .  \n    b  .  1 .   .   .  \n    c  .  1 .   .   .  \n    d  .  . 0.3 0.6 0.1\n```\n:::\n:::\n\n\nThe function currently returns a sparse matrix by default, but we can easily switch that into a base `matrix` that [`as_tbl_graph()`](https://tidygraph.data-imaginist.com/reference/tbl_graph.html) can handle:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-8_3a83436ec82e44f5b5c7d579cbb2fdea'}\n\n```{.r .cell-code}\n(tgm_abc <- mtx_abc |>\n  as.matrix() |>\n  as_tbl_graph())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tbl_graph: 9 nodes and 6 edges\n#\n# A rooted forest with 3 trees\n#\n# Node Data: 9 × 2 (active)\n  type  name \n  <lgl> <chr>\n1 FALSE a    \n2 FALSE b    \n3 FALSE c    \n4 FALSE d    \n5 TRUE  AA   \n6 TRUE  BB   \n# … with 3 more rows\n#\n# Edge Data: 6 × 3\n   from    to weight\n  <int> <int>  <dbl>\n1     1     5      1\n2     2     6      1\n3     3     6      1\n# … with 3 more rows\n```\n:::\n:::\n\n\nNotice that we now have a logical `type` attribute indicating the two disjoint `lower` and `upper` node sets. Let's try again with the bipartite layout algorithm:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-9_b1a39403e0e209bab970f4b103f84fce'}\n\n```{.r .cell-code}\ntgm_abc |>\n  ggraph(layout = \"igraph\", algorithm = \"bipartite\") +\n  geom_node_point() +\n  geom_edge_link()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nSuccess! We have something that loosely resembles my earlier hand-drawn sketch. So now we can move on to customisation using the familiar layered ggplot grammar and the extra features offered by `ggraph`'s `geom_edge_*` and `geom_node_*` families.\n\nBut before that, maybe we don't need to mess around with converting to matrices after all.\n\n### Multipartite graphs and the Sugiyama layout algorithm\n\nAs a general rule, I like things to be efficient and elegant, and the edgelist to matrix detour is neither. So, I started to dig around in the `igraph` and `tidygraph` documentation and code base to see if I could find a less clunky way of generating a bigraph layout.\n\nNow, you have to remember that I'm not a graph theorist, or network researcher so a lot of the documentation was basically gibberish to me. Then there's the added layer of traversing between `ggraph` and `igraph` layout functions (via `tidygraph`?), and untangling the relationship between the `tbl_graph` and `igraph` classes.\n\nNevertheless, I eventually stumbled across this little breadcrumb in the `igraph::layout.bipartite()` manual entry:\n\n> The layout is created by first placing the vertices in two rows, according to their types. Then the positions within the rows are optimized to minimize edge crossings, using the Sugiyama algorithm (see `layout_with_sugiyama()`).\n\nAt first glance, the [examples in `igraph::layout_with_sugiyama()`](https://r.igraph.org/reference/layout_with_sugiyama.html) don't bear much resemblance to the bipartite graph I sketched earlier. Take this example:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-10_d298b01fac74bda308026106884838d8'}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(igraph, quietly = TRUE)\n## Another example, from the following paper:\n## Markus Eiglsperger, Martin Siebenhaller, Michael Kaufmann:\n## An Efficient Implementation of Sugiyama's Algorithm for\n## Layered Graph Drawing, Journal of Graph Algorithms and\n## Applications 9, 305--325 (2005).\n\nex <- graph_from_literal(\n  0 -+ 29:6:5:20:4,\n  1 -+ 12,\n  2 -+ 23:8,\n  3 -+ 4,\n  4,\n  5 -+ 2:10:14:26:4:3,\n  6 -+ 9:29:25:21:13,\n  7,\n  8 -+ 20:16,\n  9 -+ 28:4,\n  10 -+ 27,\n  11 -+ 9:16,\n  12 -+ 9:19,\n  13 -+ 20,\n  14 -+ 10,\n  15 -+ 16:27,\n  16 -+ 27,\n  17 -+ 3,\n  18 -+ 13,\n  19 -+ 9,\n  20 -+ 4,\n  21 -+ 22,\n  22 -+ 8:9,\n  23 -+ 9:24,\n  24 -+ 12:15:28,\n  25 -+ 11,\n  26 -+ 18,\n  27 -+ 13:19,\n  28 -+ 7,\n  29 -+ 25\n)\n\nlayers <- list(\n  0, c(5, 17), c(2, 14, 26, 3), c(23, 10, 18), c(1, 24),\n  12, 6, c(29, 21), c(25, 22), c(11, 8, 15), 16, 27, c(13, 19),\n  c(9, 20), c(4, 28), 7\n)\n\nlayex <- layout_with_sugiyama(ex, layers = apply(\n  sapply(\n    layers,\n    function(x) V(ex)$name %in% as.character(x)\n  ),\n  1, which\n))\n\norigvert <- c(rep(TRUE, vcount(ex)), rep(FALSE, nrow(layex$layout.dummy)))\nrealedge <- as_edgelist(layex$extd_graph)[, 2] <= vcount(ex)\nplot(layex$extd_graph,\n  vertex.label.cex = 0.5,\n  edge.arrow.size = .5,\n  vertex.size = ifelse(origvert, 5, 0),\n  vertex.shape = ifelse(origvert, \"square\", \"none\"),\n  vertex.label = ifelse(origvert, V(ex)$name, \"\"),\n  edge.arrow.mode = ifelse(realedge, 2, 0)\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nBut wait, let's take a closer look at the documentation (emphasis mine):\n\n> This layout algorithm is designed for *directed acyclic graphs* where each vertex is assigned to a layer. Layers are indexed from zero, and vertices of the same layer will be placed on the same horizontal line. The X coordinates of vertices within each layer are decided by the heuristic proposed by Sugiyama et al. to minimize edge crossings.\n\nthe usage:\n\n``` r\nlayout_with_sugiyama(\n  graph,\n  layers = NULL,\n  hgap = 1,\n  vgap = 1,\n  maxiter = 100,\n  weights = NULL,\n  attributes = c(\"default\", \"all\", \"none\")\n)\n```\n\nand the `layers` argument:\n\n> layers\n>\n> :   A numeric vector or NULL. If not NULL, then it should specify the layer index of the vertices. Layers are numbered from one. If NULL, then igraph calculates the layers automatically.\n\nAre you following? Not quite? Well, what if I told you that *directed bipartite graphs* are just a special kind of directed acyclic graph?\n\nThen, we've found a way to bypass the `type` requirement for using `layout_as_bipartite()`, which as far as I can tell probably just converts the logical `type` attribute into a numeric vector (i.e. 0 or 1) assigning a \"layer index\" to the two types of nodes, and then calls `layout_with_sugiyama()`.\n\nTranslating this back to `ggraph::create_layout()`/`ggraph()` syntax we can get around our earlier error without fiddling with matrices by letting `layout_with_sugiyama()` work out the disjoint `lower` and `upper` sets:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-11_8f3ea6322d74b3752dccc1c9339562d1'}\n\n```{.r .cell-code}\ntg_abc |>\n  ggraph(layout = \"igraph\", algorithm = \"sugiyama\") +\n  geom_node_point() +\n  geom_edge_link()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nAnother benefit of using the Sugiyama algorithm directly is that it lends itself nicely to plotting multi-step transformations as directed multipartite graphs. We would just need to calculate a \"layer index\" for each step and let the [`ggraph`/`tidygraph` handle the rest](https://ggraph.data-imaginist.com/articles/tidygraph.html#nse-in-layout-specifications). Instead of just two disjoint sets, we could have three or more classification schemes that we transform our data between. For example, we could extend my earlier hand draw example by adding an aggregation step:\n\n![A hand-drawn multi-partite graph showing two sequential crossmap transformations](images/image-1203247235.png)\n\n### Finally, a ggplot\n\nNow, for the grand reveal:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-12_a63f371f02ef09eb7d5961d6f468d274'}\n\n```{.r .cell-code  code-fold=\"true\"}\ntg_abc |>\n  ## calculating edge properties\n  activate(edges) |>\n  mutate(frac_weight = ifelse(share < 1, TRUE, FALSE)) |>\n  mutate(edge_linetype = ifelse(frac_weight, \"dashed\", \"solid\")) |> \n  mutate(edge_label_pos = ifelse(frac_weight, 0.8, 0.2)) |>\n  ## calculating node properties\n  activate(nodes) |>\n  mutate(n_from = centrality_degree(mode = \"in\"),\n         in_from = n_from == 0,\n         collapse = n_from > 1) |>\n  ## now we plot...\n  ggraph::ggraph(layout = \"sugiyama\") +\n  ## unit weight links,\n  ggraph::geom_edge_diagonal(\n    aes(edge_linetype = I(edge_linetype),\n        edge_alpha = share,\n        filter = !frac_weight),\n    end_cap = circle(6, 'mm'),\n    show.legend = FALSE\n    ) +\n  ## frac weight links,\n  ggraph::geom_edge_diagonal(\n    aes(edge_linetype = I(edge_linetype),\n        edge_alpha = share,\n        filter = frac_weight,\n        label = share,\n        label_pos = edge_label_pos,\n        ),\n    end_cap = circle(6, 'mm'),\n    show.legend = FALSE,\n    angle_calc = \"along\",\n    label_dodge = grid::unit(2, \"mm\")\n    ) +\n  ## from nodes,\n  ggraph::geom_node_label(aes(label = name, \n                              filter=in_from),\n                          ) +\n  ## to nodes,\n  ggraph::geom_node_label(aes(label = name, \n                              fill = collapse,\n                              filter=!in_from\n                              ),\n                          show.legend = FALSE,\n                          ) +\n  scale_fill_brewer() +\n  ## and finally modify coordinates, scale and theme\n  coord_flip() +\n  scale_y_reverse() +\n  theme_minimal() +\n  ggraph::th_no_axes()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n### Let's rewind the instant replay\n\nThe first modification I made was to swap the basic `geom_node_point()` and `geom_edge_link()` for their fancier cousins `geom_node_label()` and `geom_edge_diagonal()`:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-13_73842461b25b1902e6e6cc7aba712d7b'}\n\n```{.r .cell-code}\ntg_abc |>\n  ggraph(layout = \"sugiyama\") +\n  geom_node_label(aes(label = name)) + # was: geom_node_point()\n  geom_edge_diagonal() # was: geom_edge_link()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nThen I shuffled the layer order and tweaked the coordinates, scales and theme:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-14_24f337421c5662015ad0933eaf82eeda'}\n\n```{.r .cell-code}\ntg_abc |>\n  ggraph(layout = \"sugiyama\") +\n  geom_edge_diagonal() +\n  geom_node_label(aes(label = name)) +\n  coord_flip() +\n  scale_y_reverse() +\n  theme_minimal() +\n  ggraph::th_no_axes()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\nThe final set of modifications required a bit of set up and rely heavily on the very useful but lightly documented [`filter` aesthetic](https://github.com/thomasp85/ggraph/blob/1952710711cd27929b7dd1cd14d39f493a2fd88e/vignettes/Nodes.Rmd#L79-L81) offered in all `ggraph` geoms. If you unfold the code above in [Finally, a ggplot], you'll see that I calculated a bunch of variables to partition the edges (by having or not having `frac_weight`) and nodes (by being `in_from` or in the target set). I then mapped these variables to various aesthetics in standard ggplot style.\n\n## To be continued...\n\nThat's it for today. If you want more `ggplot2` stories keep reading, otherwise stay tuned for updates from the next phase of my journey to add `autoplot()` to the `xmap` package: *Geoms, Stats and autoplot, Oh My!*\n\n## Prologue: ggplot2 Fails?\n\nObviously I'm not the first person to try and plot bipartite graphs, but navigating the wonderfully rich R and ggplot2 ecosystems to find what I needed proved much more difficult than I anticipated. Here are selections of my experiments using `geoms` from various ggplot2 extension packages:\n\n::: {layout=\"[[45,55], [1]]\"}\n![ggalluvial](https://raw.githubusercontent.com/cynthiahqy/viz-panel-maps/57272c61692ece2d2b94874d12fe7f0619c6e864/docs/plots/viz-country-concord/ggalluvial.png)\n\n![ggsankey](https://raw.githubusercontent.com/cynthiahqy/viz-panel-maps/57272c61692ece2d2b94874d12fe7f0619c6e864/docs/plots/viz-country-concord/ggsankey.png)\n\n![ggbump](https://raw.githubusercontent.com/cynthiahqy/viz-panel-maps/57272c61692ece2d2b94874d12fe7f0619c6e864/docs/plots/viz-country-concord/ggbump-sigmoid-graph-edges.jpg)\n\nAttempts at plotting bipartite graphs using `{ggalluvial}`, `{ggsankey}` and `{ggbump}`.\n:::\n\nAs you can see, my most successful Frankenstein was the `{ggbump}` graphic. Young, naive, and too intimidated to even think about reading the [\"Extending ggplot2\" vignette](https://ggplot2.tidyverse.org/articles/extending-ggplot2.html), I shoved a creative combination of `geom_text()`, `geom_label()`, `ggbump::geom_sigmoid()` and far too many ad-hoc computations in a [wrapper function](https://github.com/cynthiahqy/viz-panel-maps/blob/57272c61692ece2d2b94874d12fe7f0619c6e864/R/plt_pm_df.R) and hoped for the best. Unfortunately, I soon ran into problems because as Thomas Lin Pedersen notes in the [`{ggraph}` package](https://ggraph.data-imaginist.com/articles/Edges.html):\n\n![One does not simply draw a line between two nodes](https://raw.githubusercontent.com/thomasp85/ggraph/febab71076d7cf277cdb79b823f262b626651703/vignettes/edge_meme_wide.jpg)\n\nI made some truly unsightly ggplots with my Frankenstein wrapper function including this monstrosity:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-15_c469854debf53c6059fcbcca18785c77'}\n::: {.cell-output-display}\n![](https://user-images.githubusercontent.com/29718979/222634595-b7d8192f-a6be-4af7-ac6e-c4210a255175.png)\n:::\n:::\n\n\nAfter which, I did not stop and rethink my approach, but came up with this workaround:\n\n![A crossmap for converting Australian occupation categories (ANZSCO22) to an international standard (ISCO8) visualised as a two-column bigraph with a lookup table underneath.](https://raw.githubusercontent.com/cynthiahqy/conformr-xmap-project/7dc4f4d9e1febda1999c415a1cbf0e31a4c85148/xmap/vignettes/plot-anzsco-isco-bigraph.png)\n\nOn the surface, this workaround looks pretty good, but don't even think about resizing it, and against all principles of reproducibility, the image above is actually a screenshot of a ggplot with two tables underneath it. I couldn't work out how to get `patchwork` and `GridExtra` to hold onto my two tables with top alignment, and so I just placed a ggplot chunk on top of a `knitr::kable()` chunk and took a screenshot...\n\n### So, what did I learn?\n\nIt turns out if you squint hard enough, almost anything can be a graph. This can be both useful and frustrating, but definitely lead me to a few realisations:\n\n-   a whole lot of ggplot2 extensions and network analysis packages offer slight variations on what I'm trying to do:\n    -   [`{ggsankey}`](https://github.com/davidsjoberg/ggsankey), [`{ggalluvial}`](https://github.com/corybrunson/ggalluvial) and [`{ggparallel}`](https://github.com/heike/ggparallel) all seem to expect a meaningful aesthetic mapping for the edge width (e.g. flow amount)\n\n    -   [`{ggbump}`](https://github.com/davidsjoberg/ggbump#tutorial) produces bump charts that look a lot like directed graphs, but there's some mental gymnastics required to work out what the nodes, edges and attributes are. `ggbump::geom_sigmoid()` can probably be thought of as a more rigid variant of `ggraph::geom_edge_diagonal()`\n\n    -   [`{ggdag}`](https://github.com/r-causal/ggdag), [`{ggbipart}`](https://pedroj.github.io/bipartite_plots/), [`{ggnet2}`](https://briatte.github.io/ggnet/) also offer plots that look a bit like what I'm after, but I couldn't quite connect the dots between their network / DAG syntax and my use case.\n    -   [`{multigraph}`](https://github.com/mplex/multigraph) offers functions for plotting two-mode data, but doesn't seem to use `ggplot2` making it difficult to customise the appearance of the plots.\n-   separating the creation and analysis of graphs (i.e. [`{tidygraph}`](https://tidygraph.data-imaginist.com)) from the visualisation (i.e [`{ggraph}`](https://ggraph.data-imaginist.com/)) makes for more modular and reusable workflows (once you wrap your head around the core concepts).\n-   multipartite graphs seem to get the worst of both worlds:\n    -   they are too complicated to be neatly wrapped up into a simple ggplot2 pipeline and retain a sensible amount of flexibility (because they are graphs, and graphs are tricky).\n    -   but they also need much more rigid and specific layout features and aesthetic mappings compared to network, hierarchical and matrix layouts.\n\nAnd on that note, thanks for reading! Please feel free to \\@me on [Twitter](http://twitter.com/cynthiahqy), [Mastodon](https://fosstodon.org/@cynthiahqy), or [GitHub](https://github.com/cynthiahqy/digital-garden) with suggestions, corrections and/or ideas.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}