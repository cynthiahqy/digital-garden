{
  "hash": "e049a8190b4a48bdf8a91a21fd3ca440",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'Managing and reusing research graphics with git'\ndescription: 'Notes on using git and git submodules to version control and share images across across multiple research papers and presentations'\ndate: ''\ndate-modified: last-modified\ndraft: true\ncategories:\n  - markdown\n  - images\n  - git\nimage: https://carbon.now.sh/?bg=rgba%28255%2C255%2C255%2C1%29&t=blackboard&wt=none&l=r&width=320&ds=false&dsyoff=20px&dsblur=68px&wc=true&wa=false&pv=69px&ph=55px&ln=false&fl=1&fm=Hack&fs=14px&lh=133%25&si=false&es=2x&wm=false&code=library%28pander%29%250Amy_table%2520%257C%253E%250A%2520%2520pander%253A%253Apander%28%29\n---\n\n\n## Creating and organising research graphics\n\nI like to use scientific graphics and conceptual maps to explain and communicate my research -- so much so I recently interviewed Jess Hopf, a scientific graphic designer on The Random Sample podcast^[Find the episode wherever you listen to podcasts or via <https://www.therandomsample.com.au/podcast/scientific-graphic-design/>].\n\nNow, I often use the same images across multiple talks, papers and even posters. This raises a few problems/inconveniences:\n\n1. Constant **copying and pasting** of images from previous documents and older folders into new ones. Updating or correcting mistakes in images across multiple documents also involves an annoying amount of copying and pasting. \n2. **Finding images** across various documents is tedious at best since I can't just search for them in the same way as you can with text. Often tracking down a particular graphic involves looking through all my rendered documents, and then going back into the source document to either find and save the image, or get the file path of that image.\n3. I have **no version control** for my graphics. I'm not even particularly diligent at using unique affixs to name variants -- often I just overwrite the old image to avoid having to go through and change the image links in my markdown documents. If I'm feeling particularly lazy, I might even copy and paste images straight from my iPad (usually drawing in Notability or Concepts) into my documents, resulting in file names like `paste-01.png`.\n\n<!-- These challenges are made slightly easier by the fact that  -->\n\nAlthough in the grand scheme of things, these are all minor annoyances, they unfortunately increase the cost of incorporating graphics into my research documents -- and that's in addition to the time taken to design and create the graphics in the first place.\n\nIn order to reduce these frictions, and make implementing good research (communication) practices smoother and less time-consuming, I decided set up a `git` based solution for version controlling and reusing my various research graphics.\n\nSome notes before we proceed:\n\n- I don't have time to explain what `git` or `git submodules` are, but I can direct you to a very fun way to learn about git: the [_How Git Works_](https://wizardzines.com/zines/git/) zine by Julia Evans (`@b0rk`), and the bonus comic on [submodules](https://wizardzines.com/comics/submodules/).\n- I author (almost) all my documents in markdown rather than WYSIWYG editors like Microsoft Word or Powerpoint. This means reusing or updating images is mostly a matter of adding or replacing the relevant source image files into the folder I'm rendering my document in (i.e. by adding or updating submodule), not scrolling through a whole Word or Powerpoint document.\n\n## Version Control with git\n\nEven if the git submodules idea below seems a little too scary for you, create a git repository collecting all your project graphics is still great for the version control benefits. Just remember to commit each time you add or update an image.\n\nI made a repository for all the images I've created for my research on Ex-Post Harmonisation: [github.com/cynthiahqy/collection_crossmap-images](https://github.com/cynthiahqy/collection_crossmap-images/tree/c2facb6bff399e5bac7cc98bd22bd94d75efaa0c)\n\nThe directory structure looks like this:\n```\n.\nâ”œâ”€â”€ README.md\nâ”œâ”€â”€ README.qmd\nâ”œâ”€â”€ illustrations\nâ”‚   â”œâ”€â”€ diagram_crossmap-transform-latex.png\nâ”‚   â”œâ”€â”€ diagram_current-prov.png\nâ”‚   â”œâ”€â”€ ...\nâ”‚   â”œâ”€â”€ icon-database.png\nâ”‚   â””â”€â”€ icon-official-stats.png\nâ”œâ”€â”€ plots\nâ”‚   â”œâ”€â”€ ...\nâ”‚   â””â”€â”€ plot-isiccomb-split-by-income-groups.png\nâ””â”€â”€ screenshots\n    â”œâ”€â”€ ...\n    â””â”€â”€ asc-poster.png\n```\n\nI use the loose structure of `illustrations/` for images I draw on my iPad, `plots` for images generated with code (e.g. ggplots), and `screenshots` for images of things displayed on my screen including figures from other papers, or as the name suggests, screenshots of websites.\n\nThe commit history reminds me of what I've added to the directory and edits I've made:\n\n```\n* 106e031 add indstat ctry/year plot\n* 2533d70 update crossmap approach overview image to correct numbers\n* c31d119 add asc-poster\n* 4a35794 add crossmap aus/usa example, vis icons\n* 294acbd initial setup .gitignore\n```\n\nFinally, a bit of Quarto and R magic lets me generate a `README.md` that displays all of these images on associated GitHub repo:\n\n````{.md filename=\"README.qmd\"}\n\n````\n\nNow I have a centralised place to store and find current and past version of my images ðŸŽ‰.\n\n## Using the image collection in multiple repositories\n\nNow for the submodule magic. Let's imagine you want to access  I added the above repository of images into the repository where I'm writing slides for my upcoming talk at UseR! 2024.\n\nTo add the repo as the `images/` folder in another project\n```\ngit submodule add <repo url> images\n```\n\nIf you update the original repo (e.g. adding an image) and want to pull the changes into this repo:\n\n```\ngit submodule update --remote --merge\n```\n\nIt's probably good practice to tag specific commits as \"releases\" or \"versions\" of images attached to particular presentations, but not strictly necessary since the `.gitsubmodules` file will list the exact submodule commit that is checked out. The only thing to be careful of then is to not `git push --force` or `git rebase` and lose that commit hash.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}